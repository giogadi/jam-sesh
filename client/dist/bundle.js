/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app.jsx":
/*!*********************!*\
  !*** ./src/app.jsx ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sound.js */ \"./src/sound.js\");\n\n\n\nconst CLIENT_COLORS = ['cyan', 'magenta', 'orange', 'lightblue', 'navy', 'purple', 'aquamarine', 'darkgreen'];\nclass SequencerTable extends React.Component {\n  constructor(props) {\n    super(props);\n    this.tableContainer = React.createRef();\n  }\n  componentDidMount() {\n    this.tableContainer.current.scrollTop = this.tableContainer.current.scrollHeight;\n  }\n  render() {\n    let numRows = this.props.setting.length;\n    let numColumns = this.props.setting[0].length;\n    let rows = [];\n    for (let i = 0; i < numRows; ++i) {\n      rows.push(i);\n    }\n    let columns = [];\n    for (let i = 0; i < numColumns; ++i) {\n      columns.push(i);\n    }\n    let getButtonClass = (r, c, beatIx) => {\n      const onBeat = beatIx == c;\n      let className = this.props.setting[r][c] ? \"sequencerCell sequencerCellActive\" : \"sequencerCell sequencerCellInactive\";\n      let highlights = this.props.userHighlights;\n      for (let i = 0; i < highlights.length; ++i) {\n        if (highlights[i].row === r && highlights[i].col === c) {\n          className += \" highlightCell\";\n          break;\n        }\n      }\n      if (onBeat) {\n        className += \" OnBeat\";\n      }\n      return className;\n    };\n    let getButtonStyle = (r, c) => {\n      let highlights = this.props.userHighlights;\n      for (let i = 0; i < highlights.length; ++i) {\n        if (highlights[i].row === r && highlights[i].col === c) {\n          return {\n            borderColor: CLIENT_COLORS[highlights[i].id % CLIENT_COLORS.length]\n          };\n        }\n      }\n      return {};\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"tableContainer\",\n      ref: this.tableContainer\n    }, /*#__PURE__*/React.createElement(\"table\", {\n      className: \"sequencerTable\"\n    }, /*#__PURE__*/React.createElement(\"tbody\", null, rows.map(r => /*#__PURE__*/React.createElement(\"tr\", {\n      key: r.toString()\n    }, columns.map(c => /*#__PURE__*/React.createElement(\"td\", {\n      className: \"sequencerTd\",\n      key: c.toString()\n    }, /*#__PURE__*/React.createElement(\"button\", {\n      style: getButtonStyle(r, c),\n      className: getButtonClass(r, c, this.props.beatIx),\n      onClick: () => this.props.onClick(r, c)\n    }))))))));\n  }\n}\nclass SynthComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.cutoffInput = React.createRef();\n  }\n  componentDidMount() {\n    // This uses the typical DOM's onchange event instead of React's. We want\n    // \"only send an event after user lets go of control\", which React's version\n    // does not do.\n    this.cutoffInput.current.onchange = e => this.props.onCutoffGlobalUpdate(e.target.value);\n  }\n  render() {\n    let sliderStyle = {};\n    let sliderClass = \"filterSlider\";\n    if (this.props.cutoffHighlight !== null) {\n      let color = CLIENT_COLORS[this.props.cutoffHighlight % CLIENT_COLORS.length];\n      sliderStyle = {\n        backgroundColor: color\n      };\n    }\n    return /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"span\", {\n      className: sliderClass,\n      style: sliderStyle\n    }, /*#__PURE__*/React.createElement(\"input\", {\n      ref: this.cutoffInput,\n      type: \"range\",\n      value: this.props.cutoff,\n      onInput: e => this.props.onCutoffLocalUpdate(e.target.value),\n      min: \"0\",\n      max: \"1\",\n      step: \"0.01\"\n    })), /*#__PURE__*/React.createElement(SequencerTable, {\n      setting: this.props.sequencerMatrix,\n      beatIx: this.props.beatIx,\n      onClick: this.props.onClick,\n      userHighlights: this.props.seqHighlights\n    }));\n  }\n}\nfunction UserList(props) {\n  let getItemStyle = id => {\n    return {\n      backgroundColor: CLIENT_COLORS[id % CLIENT_COLORS.length]\n    };\n  };\n  let listItems = props.users.map(item => /*#__PURE__*/React.createElement(\"li\", {\n    key: item.id\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: getItemStyle(item.id)\n  }, item.name)));\n  return /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"p\", null, \"Connected users:\"), /*#__PURE__*/React.createElement(\"ul\", null, listItems));\n}\nfunction noteFrequency(note_ix) {\n  const MAX_NOTE_INDEX = 70;\n  if (note_ix > MAX_NOTE_INDEX || note_ix < 0) {\n    throw \"invalid note index (\" + note_ix + \")\";\n  }\n  const base_freq_ix = note_ix % _sound_js__WEBPACK_IMPORTED_MODULE_0__.BASE_FREQS.length;\n  const num_octaves_above = Math.floor(note_ix / _sound_js__WEBPACK_IMPORTED_MODULE_0__.BASE_FREQS.length);\n  return _sound_js__WEBPACK_IMPORTED_MODULE_0__.BASE_FREQS[base_freq_ix] * (1 << num_octaves_above);\n}\n\n// 16 rows.\n// row 0: noteIx 15 + 2*12\n// ro 15: noteIx 0 + 2*12\nfunction fromCellToFreq(row, numRows) {\n  let noteIx = numRows - 1 - row;\n  return noteFrequency(noteIx + _sound_js__WEBPACK_IMPORTED_MODULE_0__.NUM_CHROMATIC_NOTES * 2);\n}\nfunction fromCellToSampleIx(row, numRows) {\n  return numRows - 1 - row;\n}\nfunction openSocket() {\n  return new Promise(function (resolve, reject) {\n    let socket = new WebSocket('ws://' + window.location.hostname + ':2795', 'giogadi');\n    socket.onopen = function (e) {\n      resolve(socket);\n    };\n    socket.onerror = function (e) {\n      reject(e);\n    };\n  });\n}\nfunction filterParamToValue(param) {\n  return param * 10000;\n}\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      synthSeqTables: [],\n      synthCutoffs: [],\n      samplerTable: [],\n      users: [],\n      beatIndex: -1\n    };\n    this.username = props.username;\n    const DEFAULT_NUM_SYNTHS = 2;\n    for (let synthIx = 0; synthIx < DEFAULT_NUM_SYNTHS; ++synthIx) {\n      let seqTable = [];\n      const DEFAULT_NUM_SYNTH_ROWS = 14;\n      const DEFAULT_NUM_SYNTH_BEATS = 16;\n      for (let i = 0; i < DEFAULT_NUM_SYNTH_ROWS; ++i) {\n        let row = [];\n        for (let j = 0; j < DEFAULT_NUM_SYNTH_BEATS; ++j) {\n          row.push(0);\n        }\n        seqTable.push(row);\n      }\n      this.state.synthSeqTables.push(seqTable);\n      this.state.synthCutoffs.push(0.5);\n    }\n    const DEFAULT_NUM_SAMPLER_ROWS = 2;\n    const DEFAULT_NUM_SAMPLER_BEATS = 16;\n    for (let i = 0; i < DEFAULT_NUM_SAMPLER_ROWS; ++i) {\n      let row = [];\n      for (let j = 0; j < DEFAULT_NUM_SAMPLER_BEATS; ++j) {\n        row.push(0);\n      }\n      this.state.samplerTable.push(row);\n    }\n    this.numSamplerVoices = 2;\n    this.getNumVoices = this.getNumVoices.bind(this);\n    this.handleSynthSeqClick = this.handleSynthSeqClick.bind(this);\n    this.handleSamplerClick = this.handleSamplerClick.bind(this);\n    this.handlePlayButtonClick = this.handlePlayButtonClick.bind(this);\n    this.perBeat = this.perBeat.bind(this);\n    this.synthPerBeat = this.synthPerBeat.bind(this);\n    this.samplerPerBeat = this.samplerPerBeat.bind(this);\n    this.updateStateFromSocketEvent = this.updateStateFromSocketEvent.bind(this);\n    this.handleCutoffLocalUpdate = this.handleCutoffLocalUpdate.bind(this);\n    this.handleCutoffGlobalUpdate = this.handleCutoffGlobalUpdate.bind(this);\n    this.setSynthCutoffFromParam = this.setSynthCutoffFromParam.bind(this);\n    this.playIntervalId = null;\n    this.clientId = null;\n    this.unacknowledgedUpdates = [];\n  }\n  async componentDidMount() {\n    // TODO: this is how other people do async functions. why?\n    // const initSoundAsync = async () => {\n    //   this.sound = await initSound();\n    // };\n    // initSoundAsync();\n    this.sound = await _sound_js__WEBPACK_IMPORTED_MODULE_0__.initSound();\n\n    // Set init sound props to match the ones in App state\n    for (let i = 0; i < this.state.synthCutoffs.length && i < this.sound.synths.length; ++i) {\n      this.sound.synths[i].filterDefault = filterParamToValue(this.state.synthCutoffs[i]);\n    }\n    try {\n      this.socket = await openSocket();\n      // Send username over socket\n      let msg = {\n        Connect: {\n          username: this.username\n        }\n      };\n      const jsonStr = JSON.stringify(msg);\n      this.socket.send(jsonStr);\n      console.log(\"Sent \" + jsonStr);\n    } catch (e) {\n      this.socket = null;\n    }\n    if (this.socket !== null) {\n      this.socket.onmessage = this.updateStateFromSocketEvent;\n    }\n  }\n  updateStateFromSocketEvent(event) {\n    let incomingMsg = JSON.parse(event.data);\n    console.log(\"Received message \" + event.data);\n\n    // STATE SYNC UPDATE\n    // TODO: THIS SURE IS A HACKY WAY TO DETECT A STATE SYNC UPDATE LOL\n    if (incomingMsg.hasOwnProperty(\"synth_sequences\")) {\n      console.log(\"STATE SYNC UPDATE!\");\n      this.unacknowledgedUpdates = [];\n      let newState = incomingMsg;\n      let newSynthSeqs = [];\n      let numSynths = newState.synth_sequences.length;\n      for (let s = 0; s < numSynths; ++s) {\n        let incomingStateSeq = newState.synth_sequences[s];\n        let synthSeq = [];\n        let numRows = newState.num_synth_note_rows;\n        let numCols = incomingStateSeq.length;\n        let numVoices = incomingStateSeq[0].length;\n        for (let r = 0; r < numRows; ++r) {\n          let row = [];\n          for (let c = 0; c < numCols; ++c) {\n            row.push(0);\n          }\n          synthSeq.push(row);\n        }\n        for (let c = 0; c < numCols; ++c) {\n          for (let voiceIx = 0; voiceIx < numVoices; ++voiceIx) {\n            let v = incomingStateSeq[c][voiceIx];\n            if (v >= 0) {\n              synthSeq[v][c] = 1;\n            }\n          }\n        }\n        newSynthSeqs.push(synthSeq);\n      }\n      let newSamplerSeq = [];\n      {\n        let incomingStateSeq = newState.sampler_sequence;\n        let numRows = newState.num_sampler_note_rows;\n        let numCols = incomingStateSeq.length;\n        let numVoices = incomingStateSeq[0].length;\n        for (let r = 0; r < numRows; ++r) {\n          let row = [];\n          for (let c = 0; c < numCols; ++c) {\n            row.push(0);\n          }\n          newSamplerSeq.push(row);\n        }\n        for (let c = 0; c < numCols; ++c) {\n          for (let voiceIx = 0; voiceIx < numVoices; ++voiceIx) {\n            let v = incomingStateSeq[c][voiceIx];\n            if (v >= 0) {\n              newSamplerSeq[v][c] = 1;\n            }\n          }\n        }\n      }\n      let newUsers = [];\n      for (let i = 0; i < newState.connected_clients.length; ++i) {\n        newUsers.push({\n          id: newState.connected_clients[i][0],\n          name: newState.connected_clients[i][1],\n          lastTouched: null\n        });\n      }\n      if (this.clientId === null) {\n        // Assume last item in connected_clients is me. Get client ID from there.\n        this.clientId = newState.connected_clients[newState.connected_clients.length - 1][0];\n      }\n      for (let i = 0; i < numSynths; ++i) {\n        this.setSynthCutoffFromParam(i, newState.synth_cutoffs[i]);\n      }\n      this.setState({\n        synthSeqTables: newSynthSeqs,\n        synthCutoffs: newState.synth_cutoffs,\n        samplerTable: newSamplerSeq,\n        users: newUsers\n      });\n      return;\n    }\n\n    // OK NOT A STATE SYNC NOW\n    console.log(\"NOT A STATE SYNC\");\n    let sourceClientId = incomingMsg.client_id;\n    let generalUpdate = incomingMsg.update;\n    console.log(generalUpdate);\n    if (generalUpdate.hasOwnProperty(\"Connect\") /* || generalUpdate === \"Connect\"*/) {\n      if (this.clientId !== sourceClientId) {\n        this.setState((oldState, props) => {\n          let newUsers = oldState.users.slice();\n          newUsers.push({\n            id: sourceClientId,\n            name: generalUpdate.Connect.username,\n            lastTouched: null\n          });\n          return {\n            users: newUsers\n          };\n        });\n      }\n    } else if (generalUpdate.hasOwnProperty(\"Disconnect\") || generalUpdate === \"Disconnect\") {\n      this.setState((oldState, props) => {\n        let newUsers = [];\n        for (let i = 0; i < oldState.users.length; ++i) {\n          if (oldState.users[i].id !== sourceClientId) {\n            newUsers.push(oldState.users[i]);\n          }\n        }\n        return {\n          users: newUsers\n        };\n      });\n    }\n    if (sourceClientId === this.clientId) {\n      for (let unackIx = 0; unackIx < this.unacknowledgedUpdates.length; ++unackIx) {\n        // TODO: can element ordering cause this to mess up since server\n        // re-serializes client message?\n        let unack = this.unacknowledgedUpdates[unackIx];\n        let updateStr = JSON.stringify(incomingMsg.update);\n        // console.log(\"HOWDY \" + unackIx + \". I sent: \" + unack.raw);\n        // console.log(\"I received: \" + updateStr);\n        if (unack.raw === updateStr) {\n          console.log(\"I see my unacknowledged message!\");\n          this.unacknowledgedUpdates.splice(unackIx, 1);\n          break;\n        }\n      }\n      return;\n    }\n\n    // If we find an unacknowledged update that is in conflict with the incoming\n    // update, ignore the incoming one.\n    for (let unackIx = 0; unackIx < this.unacknowledgedUpdates.length; ++unackIx) {\n      let generalUnack = this.unacknowledgedUpdates[unackIx].parsed;\n      if (generalUnack.hasOwnProperty(\"SynthSeq\")) {\n        if (generalUpdate.hasOwnProperty(\"SynthSeq\")) {\n          let unack = generalUnack.SynthSeq;\n          let update = generalUpdate.SynthSeq;\n          if (unack.synth_ix === update.synth_ix && unack.beat_ix === update.beat_ix) {\n            console.log(`Ignoring update: ${update}`);\n            return;\n          }\n        }\n      } else if (generalUnack.hasOwnProperty(\"SamplerSeq\")) {\n        if (generalUpdate.hasOwnProperty(\"SamplerSeq\")) {\n          let unack = generalUnack.SamplerSeq;\n          let update = generalUpdate.SamplerSeq;\n          if (unack.beat_ix === update.beat_ix) {\n            console.log(`Ignoring update: ${update}`);\n            return;\n          }\n        }\n      } else if (generalUnack.hasOwnProperty(\"SynthFilterCutoff\")) {\n        if (generalUpdate.hasOwnProperty(\"SynthFilterCutoff\")) {\n          let unack = generalUnack.SynthFilterCutoff;\n          let update = generalUpdate.SynthFilterCutoff;\n          if (unack.synth_ix === update.synth_ix) {\n            console.log(`Ignoring update: ${update}`);\n            return;\n          }\n        }\n      }\n    }\n    if (generalUpdate.hasOwnProperty(\"SynthSeq\")) {\n      // TODO: do validation of voices\n      let update = generalUpdate.SynthSeq;\n      this.setState((oldState, props) => {\n        let newSynthSeqs = oldState.synthSeqTables.slice();\n        {\n          newSynthSeqs[update.synth_ix] = oldState.synthSeqTables[update.synth_ix].slice();\n          let newSynthSeqTable = newSynthSeqs[update.synth_ix];\n          let numRows = newSynthSeqTable.length;\n          for (let r = 0; r < numRows; ++r) {\n            newSynthSeqTable[r][update.beat_ix] = 0;\n          }\n          let numVoices = update.active_cell_ixs.length;\n          for (let voiceIx = 0; voiceIx < numVoices; ++voiceIx) {\n            let v = update.active_cell_ixs[voiceIx];\n            if (v >= 0) {\n              newSynthSeqTable[v][update.beat_ix] = 1;\n            }\n          }\n        }\n        let newUsers = oldState.users.slice();\n        for (let i = 0; i < newUsers.length; ++i) {\n          if (newUsers[i].id === sourceClientId) {\n            newUsers[i].lastTouched = {\n              type: \"synth_seq\",\n              synthIx: update.synth_ix,\n              row: update.clicked_cell_ix,\n              col: update.beat_ix\n            };\n          }\n        }\n        return {\n          synthSeqTables: newSynthSeqs,\n          users: newUsers\n        };\n      });\n    } else if (generalUpdate.hasOwnProperty(\"SamplerSeq\")) {\n      let update = generalUpdate.SamplerSeq;\n      this.setState((oldState, props) => {\n        let newSeqTable = oldState.samplerTable.slice();\n        let numRows = newSeqTable.length;\n        for (let r = 0; r < numRows; ++r) {\n          newSeqTable[r][update.beat_ix] = 0;\n        }\n        let numVoices = update.active_cell_ixs.length;\n        for (let voiceIx = 0; voiceIx < numVoices; ++voiceIx) {\n          let v = update.active_cell_ixs[voiceIx];\n          if (v >= 0) {\n            newSeqTable[v][update.beat_ix] = 1;\n          }\n        }\n        let newUsers = oldState.users.slice();\n        for (let i = 0; i < newUsers.length; ++i) {\n          if (newUsers[i].id === sourceClientId) {\n            newUsers[i].lastTouched = {\n              type: \"sampler_seq\",\n              row: update.clicked_cell_ix,\n              col: update.beat_ix\n            };\n          }\n        }\n        return {\n          samplerTable: newSeqTable,\n          users: newUsers\n        };\n      });\n    } else if (generalUpdate.hasOwnProperty(\"SynthFilterCutoff\")) {\n      let update = generalUpdate.SynthFilterCutoff;\n      this.setState((oldState, props) => {\n        let newCutoffs = oldState.synthCutoffs.slice();\n        newCutoffs[update.synth_ix] = update.value;\n        this.setSynthCutoffFromParam(update.synth_ix, update.value);\n        let newUsers = oldState.users.slice();\n        for (let i = 0; i < newUsers.length; ++i) {\n          if (newUsers[i].id === sourceClientId) {\n            newUsers[i].lastTouched = {\n              type: \"synth_cutoff\",\n              synthIx: update.synth_ix,\n              value: update.value\n            };\n          }\n        }\n        return {\n          synthCutoffs: newCutoffs,\n          users: newUsers\n        };\n      });\n    }\n  }\n  getNumVoices(synthIx) {\n    return this.sound.synths[synthIx].voices.length;\n  }\n  synthPerBeat(beatIndex) {\n    let numSynths = this.state.synthSeqTables.length;\n    for (let synthIx = 0; synthIx < numSynths; ++synthIx) {\n      let numRows = this.state.synthSeqTables[synthIx].length;\n      let numBeats = this.state.synthSeqTables[synthIx][0].length;\n      let voices = [];\n      for (let row = 0; row < numRows; ++row) {\n        if (this.state.synthSeqTables[synthIx][row][beatIndex]) {\n          voices.push(fromCellToFreq(row, numRows));\n        }\n      }\n      console.assert(voices.length <= this.getNumVoices(0));\n      _sound_js__WEBPACK_IMPORTED_MODULE_0__.synthPlayVoices(this.sound.synths[synthIx], voices, this.sound.audioCtx);\n    }\n  }\n  samplerPerBeat(beatIndex) {\n    let numRows = this.state.samplerTable.length;\n    let numBeats = this.state.samplerTable[0].length;\n    let cellIx;\n    for (let row = 0; row < numRows; ++row) {\n      if (this.state.samplerTable[row][beatIndex]) {\n        cellIx = fromCellToSampleIx(row, numRows);\n        console.assert(cellIx < this.sound.drumSounds.length);\n        _sound_js__WEBPACK_IMPORTED_MODULE_0__.playSoundFromBuffer(this.sound.audioCtx, this.sound.drumSounds[cellIx]);\n      }\n    }\n  }\n  perBeat() {\n    // TODO!!!!!! We should make this allow for different beat lengths on different sequencers.\n    let numBeats = this.state.synthSeqTables[0][0].length;\n\n    // TODO: might be a problem to depend on current state here\n    let newBeatIx = (this.state.beatIndex + 1) % numBeats;\n    console.assert(newBeatIx >= 0);\n    this.synthPerBeat(newBeatIx);\n    this.samplerPerBeat(newBeatIx);\n\n    // NOTE: THE PARENTHESIS RIGHT AFTER THE ARROW IS EXTREMELY IMPORTANT!!!!!\n    this.setState((state, props) => ({\n      beatIndex: newBeatIx\n    }));\n  }\n  handlePlayButtonClick() {\n    if (this.playIntervalId === null) {\n      let bpm = 200;\n      const ticksPerBeat = 1 / bpm * 60 * 1000;\n      this.playIntervalId = window.setInterval(this.perBeat, ticksPerBeat);\n      this.setState({\n        beatIndex: -1\n      });\n    } else {\n      window.clearInterval(this.playIntervalId);\n      this.playIntervalId = null;\n      this.setState({\n        beatIndex: -1\n      });\n    }\n  }\n  setSynthCutoffFromParam(synthIx, newCutoffParam) {\n    this.sound.synths[synthIx].filterDefault = filterParamToValue(newCutoffParam);\n  }\n  handleCutoffLocalUpdate(synthIx, newCutoffParamStr) {\n    const newCutoffParam = parseFloat(newCutoffParamStr);\n    this.setSynthCutoffFromParam(synthIx, newCutoffParam);\n    let newCutoffs = this.state.synthCutoffs.slice();\n    newCutoffs[synthIx] = newCutoffParam;\n    this.setState({\n      synthCutoffs: newCutoffs\n    });\n  }\n  handleCutoffGlobalUpdate(synthIx, newCutoffParamStr) {\n    // TODO: do I need to do the local update stuff too or can I just assume\n    // that the local update will have already run?\n    if (this.socket !== null) {\n      let msg = {\n        SynthFilterCutoff: {\n          synth_ix: synthIx,\n          value: parseFloat(newCutoffParamStr)\n        }\n      };\n      const jsonStr = JSON.stringify(msg);\n      this.unacknowledgedUpdates.push({\n        raw: jsonStr,\n        parsed: msg\n      });\n      this.socket.send(jsonStr);\n      console.log(\"Sent \" + jsonStr);\n    }\n  }\n\n  // If it returns null, then no change to seq\n  newSeqFromClick(seq, row, col, numVoices) {\n    const numRows = seq.length;\n\n    // QUESTION: is it safe to define newTable in terms of state *outside of this.setState* \n    // and then set new state w.r.t. newTable (and therefore in terms of old state)??\n    if (!seq[row][col]) {\n      // count number of active voices in this column\n      let activeVoices = 0;\n      for (let r = 0; r < numRows; ++r) {\n        if (seq[r][col]) {\n          ++activeVoices;\n        }\n      }\n      if (activeVoices >= numVoices) {\n        return null;\n      }\n    }\n    let newTable = seq.slice();\n    newTable[row][col] = newTable[row][col] ? 0 : 1;\n    return newTable;\n  }\n\n  // TODO: do they have to be TOTAL copies?\n  newSeqsFromClick(seqs, clickedSynthIx, row, col, numVoices) {\n    let newClickedSeq = this.newSeqFromClick(seqs[clickedSynthIx], row, col, numVoices);\n    if (newClickedSeq === null) {\n      // If no changes, return null to signify no changes.\n      return null;\n    }\n    let newTables = seqs.slice();\n    newTables[clickedSynthIx] = newClickedSeq;\n    return newTables;\n  }\n  handleSynthSeqClick(synthIx, row, col) {\n    let newTables = this.newSeqsFromClick(this.state.synthSeqTables, synthIx, row, col, this.getNumVoices(synthIx));\n    if (newTables === null) {\n      return;\n    }\n    this.setState({\n      synthSeqTables: newTables\n    });\n    if (this.socket !== null) {\n      let activeCellIxs = [];\n      let numVoices = this.getNumVoices(synthIx);\n      for (let voiceIx = 0; voiceIx < numVoices; ++voiceIx) {\n        activeCellIxs.push(-1);\n      }\n      let numRows = newTables[synthIx].length;\n      let voiceIx = 0;\n      for (let r = 0; r < numRows; ++r) {\n        if (newTables[synthIx][r][col] === 1) {\n          activeCellIxs[voiceIx] = r;\n          ++voiceIx;\n        }\n      }\n      const msg = {\n        SynthSeq: {\n          synth_ix: synthIx,\n          beat_ix: col,\n          active_cell_ixs: activeCellIxs,\n          clicked_cell_ix: row\n        }\n      };\n      const jsonMsg = JSON.stringify(msg);\n      this.unacknowledgedUpdates.push({\n        raw: jsonMsg,\n        parsed: msg\n      });\n      this.socket.send(jsonMsg);\n      console.log(\"Sent \" + jsonMsg);\n    }\n  }\n  handleSamplerClick(row, col) {\n    let newTable = this.newSeqFromClick(this.state.samplerTable, row, col, 2);\n    if (newTable === null) {\n      return;\n    }\n    this.setState({\n      samplerTable: newTable\n    });\n    if (this.socket !== null) {\n      let activeCellIxs = [];\n      let numVoices = this.numSamplerVoices;\n      for (let voiceIx = 0; voiceIx < numVoices; ++voiceIx) {\n        activeCellIxs.push(-1);\n      }\n      let numRows = newTable.length;\n      let voiceIx = 0;\n      for (let r = 0; r < numRows; ++r) {\n        if (newTable[r][col] === 1) {\n          activeCellIxs[voiceIx] = r;\n          ++voiceIx;\n        }\n      }\n      const msg = {\n        SamplerSeq: {\n          beat_ix: col,\n          active_cell_ixs: activeCellIxs,\n          clicked_cell_ix: row\n        }\n      };\n      const jsonMsg = JSON.stringify(msg);\n      this.unacknowledgedUpdates.push({\n        raw: jsonMsg,\n        parsed: msg\n      });\n      this.socket.send(jsonMsg);\n      console.log(\"Sent \" + jsonMsg);\n    }\n  }\n  render() {\n    let synthIxs = [];\n    let synthSeqHighlights = [];\n    let synthCutoffHighlights = [];\n    for (let i = 0; i < this.state.synthSeqTables.length; ++i) {\n      synthIxs.push(i);\n      synthSeqHighlights.push([]);\n      synthCutoffHighlights.push(null);\n    }\n    let samplerSeqHighlights = [];\n    for (let i = 0; i < this.state.users.length; ++i) {\n      let lastTouched = this.state.users[i].lastTouched;\n      if (lastTouched !== null) {\n        let touchType = lastTouched.type;\n        if (touchType === \"synth_seq\") {\n          synthSeqHighlights[lastTouched.synthIx].push({\n            id: this.state.users[i].id,\n            row: lastTouched.row,\n            col: lastTouched.col\n          });\n        } else if (touchType === \"sampler_seq\") {\n          samplerSeqHighlights.push({\n            id: this.state.users[i].id,\n            row: lastTouched.row,\n            col: lastTouched.col\n          });\n        } else if (touchType === \"synth_cutoff\") {\n          synthCutoffHighlights[lastTouched.synthIx] = this.state.users[i].id;\n        }\n      }\n    }\n    return /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(UserList, {\n      users: this.state.users\n    }), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: this.handlePlayButtonClick\n    }, \"Play/Stop\"), synthIxs.map(s => /*#__PURE__*/React.createElement(\"div\", {\n      key: s.toString()\n    }, /*#__PURE__*/React.createElement(SynthComponent, {\n      sequencerMatrix: this.state.synthSeqTables[s],\n      cutoff: this.state.synthCutoffs[s],\n      beatIx: this.state.beatIndex,\n      onClick: (r, c) => this.handleSynthSeqClick(s, r, c),\n      onCutoffLocalUpdate: cutoff => this.handleCutoffLocalUpdate(s, cutoff),\n      onCutoffGlobalUpdate: cutoff => this.handleCutoffGlobalUpdate(s, cutoff),\n      seqHighlights: synthSeqHighlights[s],\n      cutoffHighlight: synthCutoffHighlights[s]\n    }), /*#__PURE__*/React.createElement(\"br\", null))), /*#__PURE__*/React.createElement(SequencerTable, {\n      setting: this.state.samplerTable,\n      beatIx: this.state.beatIndex,\n      onClick: this.handleSamplerClick,\n      userHighlights: samplerSeqHighlights\n    }));\n  }\n}\nasync function main() {\n  // Let's wait for a mouse click before doing anything\n  // let msg = document.getElementById('message');\n  // msg.innerHTML = 'Click to start';\n  let submitButton = document.getElementById('submit_name');\n  const waitForClick = () => new Promise(resolve => {\n    submitButton.addEventListener('click', () => resolve(), {\n      once: true\n    });\n  });\n  await waitForClick();\n  let usernameField = document.getElementById('name');\n  let username = usernameField.value;\n  document.getElementById('message').remove();\n  usernameField.remove();\n  submitButton.remove();\n  const domContainer = document.querySelector('#root');\n  const root = ReactDOM.createRoot(domContainer);\n  root.render( /*#__PURE__*/React.createElement(App, {\n    username: username\n  }));\n}\nmain();\n\n//# sourceURL=webpack://client/./src/app.jsx?");

/***/ }),

/***/ "./src/sound.js":
/*!**********************!*\
  !*** ./src/sound.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_FREQS: () => (/* binding */ BASE_FREQS),\n/* harmony export */   NOTES: () => (/* binding */ NOTES),\n/* harmony export */   NUM_CHROMATIC_NOTES: () => (/* binding */ NUM_CHROMATIC_NOTES),\n/* harmony export */   getFreq: () => (/* binding */ getFreq),\n/* harmony export */   initSound: () => (/* binding */ initSound),\n/* harmony export */   playSoundFromBuffer: () => (/* binding */ playSoundFromBuffer),\n/* harmony export */   synthPlayVoice: () => (/* binding */ synthPlayVoice),\n/* harmony export */   synthPlayVoices: () => (/* binding */ synthPlayVoices),\n/* harmony export */   synthReleaseVoice: () => (/* binding */ synthReleaseVoice)\n/* harmony export */ });\n\nfunction getSoundData(filename) {\n  return new Promise(function (resolve, reject) {\n    let pathname = window.location.pathname;\n    pathname = pathname.substring(0, pathname.lastIndexOf('/'));\n    let request = new XMLHttpRequest();\n    let url = 'http://' + window.location.hostname + \":\" + window.location.port + pathname + \"/\" + filename;\n    console.log(url);\n    request.open('GET', url);\n    request.responseType = 'arraybuffer';\n    request.onload = function () {\n      resolve(request.response);\n    };\n    request.onerror = function () {\n      reject(request.statusText);\n    };\n    request.send();\n  });\n}\nconst BASE_FREQS = [55.0000,\n// A\n58.2705,\n// A#\n61.7354,\n// B\n65.4064,\n// C\n69.2957,\n// C#\n73.4162,\n// D\n77.7817,\n// D#\n82.4069,\n// E\n87.3071,\n// F\n92.4986,\n// F#\n97.9989,\n// G\n103.826 // G#\n];\nconst NOTES = {\n  A: 0,\n  A_S: 1,\n  B_F: 1,\n  B: 2,\n  C: 3,\n  C_S: 4,\n  D_F: 4,\n  D: 5,\n  D_S: 6,\n  E_F: 6,\n  E: 7,\n  F: 8,\n  F_S: 9,\n  G_F: 9,\n  G: 10,\n  G_S: 11,\n  A_F: 11\n};\nconst NUM_CHROMATIC_NOTES = 12;\nfunction getFreq(note, octave) {\n  return BASE_FREQS[note] * (1 << octave);\n}\nfunction initSynth(audioCtx, synthSpec, masterGain) {\n  // TODO: consider making this more efficient if no modulation gain/freq are 0.\n  let filterNode = audioCtx.createBiquadFilter();\n  filterNode.type = 'lowpass';\n  filterNode.frequency.setValueAtTime(synthSpec.filterCutoff, audioCtx.currentTime);\n  filterNode.Q.value = synthSpec.filterQ;\n  let filterModFreq = audioCtx.createOscillator();\n  filterModFreq.frequency.setValueAtTime(synthSpec.filterModFreq, audioCtx.currentTime);\n  let filterModGain = audioCtx.createGain();\n  filterModGain.gain.setValueAtTime(synthSpec.filterModGain, audioCtx.currentTime);\n  filterModFreq.connect(filterModGain).connect(filterNode.frequency);\n  filterModFreq.start();\n  let gainNode = audioCtx.createGain();\n  gainNode.gain.setValueAtTime(synthSpec.gain, audioCtx.currentTime);\n  filterNode.connect(gainNode);\n  gainNode.connect(masterGain);\n  let voices = [];\n  for (let i = 0; i < synthSpec.voiceSpecs.length; ++i) {\n    // TODO: consider making this more efficient if osc2Gain == 0 by only initializing one oscillator.\n    let osc2Detune = synthSpec.voiceSpecs[i].osc2Detune;\n    let osc2GainValue = synthSpec.voiceSpecs[i].osc2Gain;\n    let defaultFreq = getFreq(NOTES.A, 3);\n    let osc1 = audioCtx.createOscillator();\n    osc1.type = synthSpec.voiceSpecs[i].osc1Type;\n    osc1.frequency.setValueAtTime(defaultFreq, audioCtx.currentTime);\n    let osc2 = audioCtx.createOscillator();\n    osc2.type = synthSpec.voiceSpecs[i].osc2Type;\n    osc2.detune.setValueAtTime(osc2Detune, audioCtx.currentTime);\n    osc2.frequency.setValueAtTime(defaultFreq, audioCtx.currentTime);\n    let voiceGainNode = audioCtx.createGain();\n    voiceGainNode.gain.setValueAtTime(0.0, audioCtx.currentTime);\n    voiceGainNode.connect(filterNode);\n    osc1.connect(voiceGainNode);\n    let osc2GainNode = audioCtx.createGain();\n    osc2GainNode.gain.setValueAtTime(osc2GainValue, audioCtx.currentTime);\n    osc2GainNode.connect(voiceGainNode);\n    osc2.connect(osc2GainNode);\n    osc1.start();\n    osc2.start();\n    voices.push({\n      osc1: osc1,\n      osc2: osc2,\n      gain: voiceGainNode,\n      osc2Gain: osc2GainNode\n    });\n  }\n  return {\n    voices: voices,\n    filter: filterNode,\n    filterModFreq: filterModFreq,\n    filterModGain: filterModGain,\n    gain: gainNode,\n    attackTime: synthSpec.attackTime,\n    decayTime: synthSpec.decayTime === undefined ? 0.0 : synthSpec.decayTime,\n    sustainLevel: synthSpec.sustainLevel === undefined ? 1.0 : synthSpec.sustainLevel,\n    releaseTime: synthSpec.releaseTime,\n    filterDefault: synthSpec.filterCutoff,\n    // TODO: These should be per-voice.\n    filterEnvAttack: synthSpec.filterEnvAttack,\n    filterEnvRelease: synthSpec.filterEnvRelease,\n    filterEnvIntensity: synthSpec.filterEnvIntensity\n  };\n}\nfunction initSound() {\n  // let soundNames = ['kick', 'hihat', 'cowbell', 'drone'];\n  let soundNames = ['kick', 'snare'];\n  let sounds = soundNames.map(function (soundName) {\n    return getSoundData(soundName + '.wav');\n  });\n  let audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n  return Promise.all(sounds).then(function (loadedSounds) {\n    return Promise.all(loadedSounds.map(function (loadedSound) {\n      return audioCtx.decodeAudioData(loadedSound);\n    }));\n  }).then(function (decodedSounds) {\n    let masterGain = audioCtx.createGain();\n    masterGain.connect(audioCtx.destination);\n    let synthSpecs = [{\n      gain: 0.25,\n      filterCutoff: 1100,\n      filterQ: 0.0,\n      filterModFreq: 0,\n      filterModGain: 0,\n      attackTime: 0.0,\n      releaseTime: 0.07,\n      filterEnvAttack: 0.0,\n      filterEnvRelease: 0.0,\n      filterEnvIntensity: 0.0,\n      voiceSpecs: [{\n        osc1Type: 'square',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.5,\n        osc2Detune: 50\n      }, {\n        osc1Type: 'square',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.5,\n        osc2Detune: 50\n      }]\n    }, {\n      gain: 0.25,\n      filterCutoff: 1100,\n      filterModFreq: 0,\n      filterQ: 0.0,\n      filterModGain: 0,\n      attackTime: 0.0,\n      releaseTime: 0.07,\n      filterEnvAttack: 0.0,\n      filterEnvRelease: 0.0,\n      filterEnvIntensity: 0.0,\n      voiceSpecs: [{\n        osc1Type: 'square',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.0,\n        osc2Detune: 0\n      }]\n    }, {\n      // Filter mod env test\n      gain: 0.25,\n      filterCutoff: 50,\n      filterModFreq: 0,\n      filterQ: 16.0,\n      filterModGain: 0,\n      attackTime: 0.0,\n      releaseTime: 0.3,\n      filterEnvAttack: 0.05,\n      filterEnvRelease: 0.1,\n      filterEnvIntensity: 300.0,\n      voiceSpecs: [{\n        osc1Type: 'sawtooth',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.3,\n        osc2Detune: -1200\n      }]\n    }, {\n      // Bass\n      gain: 0.5,\n      filterCutoff: 300,\n      filterQ: 0.0,\n      filterModFreq: 0,\n      filterModGain: 0,\n      attackTime: 0.0,\n      releaseTime: 0.5,\n      filterEnvAttack: 0.0,\n      filterEnvRelease: 0.0,\n      filterEnvIntensity: 0.0,\n      voiceSpecs: [{\n        osc1Type: 'square',\n        osc2Type: 'sine',\n        osc2Gain: 0.0,\n        osc2Detune: 0.0\n      }]\n    }, {\n      // Laserbeam chord\n      gain: 0.25,\n      filterCutoff: 10000.0,\n      filterQ: 0.0,\n      filterModFreq: 0,\n      filterModGain: 0,\n      attackTime: 0.001,\n      decayTime: 0.025,\n      sustainLevel: 0.1,\n      releaseTime: 0.2,\n      filterEnvAttack: 0.0,\n      filterEnvRelease: 0.0,\n      filterEnvIntensity: 0.0,\n      voiceSpecs: [{\n        osc1Type: 'sawtooth',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.8,\n        osc2Detune: 30.0\n      }, {\n        osc1Type: 'sawtooth',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.8,\n        osc2Detune: 20.0\n      }, {\n        osc1Type: 'sawtooth',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.8,\n        osc2Detune: 20.0\n      }, {\n        osc1Type: 'sawtooth',\n        osc2Type: 'sawtooth',\n        osc2Gain: 0.8,\n        osc2Detune: 20.0\n      }]\n    }];\n    let synths = [];\n    let auxSynths = [];\n    for (let i = 0; i < synthSpecs.length; ++i) {\n      synths.push(initSynth(audioCtx, synthSpecs[i], masterGain));\n      auxSynths.push(initSynth(audioCtx, synthSpecs[i], masterGain));\n    }\n\n    // drone sound\n    // let droneSource = audioCtx.createBufferSource();\n    // droneSource.buffer = decodedSounds[3];\n    // droneSource.loop = true;\n    // droneSource.loopStart = 1.0;\n    // // SUPER weird: for some reason we *need* to set loopEnd for the sample to loop correctly\n    // // (even though the sample length is exactly this length).\n    // droneSource.loopEnd = 4.0\n    // let droneFilter = audioCtx.createBiquadFilter();\n    // droneFilter.type = 'lowpass';\n    // // droneFilter.frequency.setValueAtTime(100, audioCtx.currentTime);\n    // droneFilter.frequency.value = 100.0;\n    // let droneGain = audioCtx.createGain();\n    // // droneGain.gain.setValueAtTime(0.25, audioCtx.currentTime);\n    // droneGain.gain.value = 0.0;\n    // droneSource.connect(droneFilter);\n    // droneFilter.connect(droneGain);\n    // droneGain.connect(masterGain);\n    // droneSource.start(0);\n\n    let sampleSounds = [];\n    for (let i = 0; i < decodedSounds.length; ++i) {\n      let sampleGainNode = audioCtx.createGain();\n      sampleGainNode.gain.value = 0.5;\n      sampleGainNode.connect(masterGain);\n      sampleSounds.push({\n        buffer: decodedSounds[i],\n        gainNode: sampleGainNode\n      });\n    }\n    // Set hihat to lower gain\n    sampleSounds[1].gainNode.gain.value = 0.15;\n    return {\n      audioCtx: audioCtx,\n      drumSounds: sampleSounds,\n      // droneNode: droneSource,\n      // droneFilter: droneFilter,\n      // droneGain: droneGain,\n      synths: synths,\n      auxSynths: auxSynths,\n      masterGain: masterGain\n    };\n  });\n}\nfunction adsrEnvelope(audioParam, currentTime, velocity, attackTime, decayTime, sustainLevel, releaseTime) {\n  audioParam.cancelScheduledValues(currentTime);\n  audioParam.setValueAtTime(0.0, currentTime);\n  audioParam.linearRampToValueAtTime(velocity, currentTime + attackTime);\n  audioParam.linearRampToValueAtTime(sustainLevel * velocity, currentTime + attackTime + decayTime);\n  audioParam.linearRampToValueAtTime(0.0, currentTime + attackTime + decayTime + releaseTime);\n}\nfunction synthPlayVoice(synth, voiceIdx, freq, sustain, audioCtx, velocity = 1.0) {\n  let voice = synth.voices[voiceIdx];\n  voice.osc1.frequency.setValueAtTime(freq, audioCtx.currentTime);\n  voice.osc2.frequency.setValueAtTime(freq, audioCtx.currentTime);\n  adsrEnvelope(voice.gain.gain, audioCtx.currentTime, velocity, synth.attackTime, synth.decayTime, synth.sustainLevel, synth.releaseTime);\n  synth.filter.frequency.cancelScheduledValues(audioCtx.currentTime);\n  synth.filter.frequency.setValueAtTime(synth.filterDefault, audioCtx.currentTime);\n  synth.filter.frequency.linearRampToValueAtTime(synth.filterDefault + synth.filterEnvIntensity, audioCtx.currentTime + synth.filterEnvAttack);\n  synth.filter.frequency.linearRampToValueAtTime(synth.filterDefault, audioCtx.currentTime + synth.filterEnvAttack + synth.filterEnvRelease);\n}\n\n// TODO: dedup with above function.\nfunction synthPlayVoices(synth, freqs, audioCtx, velocity = 1.0) {\n  let seenFreqs = new Set();\n  for (let i = 0; i < freqs.length && i < synth.voices.length; ++i) {\n    if (seenFreqs.has[freqs[i]]) {\n      continue;\n    }\n    seenFreqs.add(freqs[i]);\n    let voice = synth.voices[i];\n    voice.osc1.frequency.setValueAtTime(freqs[i], audioCtx.currentTime);\n    voice.osc2.frequency.setValueAtTime(freqs[i], audioCtx.currentTime);\n    adsrEnvelope(voice.gain.gain, audioCtx.currentTime, velocity, synth.attackTime, synth.decayTime, synth.sustainLevel, synth.releaseTime);\n  }\n  synth.filter.frequency.cancelScheduledValues(audioCtx.currentTime);\n  synth.filter.frequency.setValueAtTime(synth.filterDefault, audioCtx.currentTime);\n  synth.filter.frequency.linearRampToValueAtTime(synth.filterDefault + synth.filterEnvIntensity, audioCtx.currentTime + synth.filterEnvAttack);\n  synth.filter.frequency.linearRampToValueAtTime(synth.filterDefault, audioCtx.currentTime + synth.filterEnvAttack + synth.filterEnvRelease);\n}\nfunction synthReleaseVoice(synth, voiceIdx, audioCtx) {\n  let voice = synth.voices[voiceIdx];\n  voice.gain.gain.setValueAtTime(0.0, audioCtx.currentTime);\n}\nfunction playSoundFromBuffer(audioCtx, sampleSound, velocity = 1.0) {\n  let source = audioCtx.createBufferSource();\n  source.buffer = sampleSound.buffer;\n  // Maybe cache this yo\n  let velGain = audioCtx.createGain();\n  velGain.gain.value = velocity;\n  source.connect(velGain);\n  velGain.connect(sampleSound.gainNode);\n  // source.connect(sampleSound.gainNode);\n  source.start(0);\n}\n\n//# sourceURL=webpack://client/./src/sound.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.jsx");
/******/ 	
/******/ })()
;